# Java篇

## 1.hashCode和equals方法的区别和联系

equals方法是Object类的一个方法，而Java中所有类都继承Object类，所以所有类都有equals方法，equals方法比较的是两个对象是否是同一个对象。

```java
public boolean equals(Object obj) {
    return (this == obj);
}
```

而对于一般的类/自定义类（除了String类），在没有重写equals方法时，使用equals方法比较的是两个对象是否相同，也就是是否是同一个对象。

```Java
class Score{
    int score;

    public Score(int score) {
        this.score = score;
    }
}
public class Test {

    public static void main(String[] args) {
        Score score1 = new Score(5);
        Score score2 = new Score(5);
        System.out.println(score1.equals(score2));//false，因为score1和score2不是同一个对象
    }
}
```

而String类已经重写了equals方法

1. 当两个对象是同一个对象时，返回true；
2. 当两个String对象的内容也相同时（字面一样），也会返回true。

```java
public boolean equals(Object anObject) {
    if (this == anObject) {
        return true;
    }
    if (anObject instanceof String) {
        String anotherString = (String)anObject;
        int n = value.length;
        if (n == anotherString.value.length) {
            char v1[] = value;
            char v2[] = anotherString.value;
            int i = 0;
            while (n-- != 0) {
                if (v1[i] != v2[i])
                    return false;
                i++;
            }
            return true;
        }
    }
    return false;
}
```

而hashCode是一个计算hash值的一个函数，同样也是Object类的一个方法，意味着Java中所有类都有该方法。

```java
public native int hashCode();
```

**两者之间的联系：**

Java的容器类被分为Collection和Map，而Collection又分为List和Set，其中Map和Set是不允许出现重复元素，Map存储的是key-value的键值对，严格来说Map不允许重复的键值对存在，像HashMap，HashSet，HashTable。

官方文档提醒我们当我们重写了equals方法后，也要重写hashCode方法，然后一般情况下我们是不会使用hashCode这个方法的，在有关散列表（哈希表）这种数据结构才会使用到hashCode方法。

那么对于底层是散列表（哈希表）这种数据结构来说，通过hashCode方法计算hash值来确定位置时，当出现冲突后，则需要equals方法来判断该位置的元素是否与要插入的元素相同。



# 把美团那两个题看看，还有网易的两个题，再把面试题整理一下